//
//  Fugu15.swift
//  Fugu15KernelExploit
//
//  Created by Linus Henze.
//  Copyright Â© 2021/2022 Pinauten GmbH. All rights reserved.
//

import Foundation
import ProcessCommunication
import CBindings
import KernelPatchfinder

var cachedBootInfo = NSMutableDictionary()

public enum JailbreakError: Error {
	case custom(_: String)
}

extension Fugu15 {
    internal static func serverMain(checkin: DKCheckinData) -> Never {
        setsid()
        
        let controlIn = FileHandle(fileDescriptor: Int32(CommandLine.arguments[2])!, closeOnDealloc: true)
        let controlOut = FileHandle(fileDescriptor: Int32(CommandLine.arguments[3])!, closeOnDealloc: true)
        
        let comm = ProcessCommunication(read: controlIn, write: controlOut)
        let bootInfoSetNames = ["physical_ttep", "jailbreakd_pac_allocation", "launchd_pac_allocation", "boomerang_pac_allocation"]
        
        var exitStatus: Int32?
        var done = false
        var exceptionHandler: UInt64?
        var detach = false
        
        while true {
            guard let cmd = comm.receiveCommand() else {
                // Probably broken pipe
                if !detach {
                    exit(-1)
                }
                
                Logger.logFileHandle = nil
                dispatchMain()
            }
            
            switch cmd[0] {
            case "ping":
                Logger.print("Hello from kernel exploit server!")
                Logger.print("My UID is \(getuid())")
                Logger.print("My GID is \(getgid())")
                
                comm.sendCommand("pong")
                
            case "pwn":
                do {
                    Logger.status("Launching oobPCI")
                    
                    guard cmd.count == 2 else {
                        comm.sendCommand("error", "Usage: pwn <oobPCI path>")
                        
                        break
                    }
                    
                    var args: [String] = []
                    if ProcessInfo.processInfo.operatingSystemVersion.minorVersion == 5 {
                        args.append("155")
                    }
                    
                    let driver = SpawnDrv(executable: URL(fileURLWithPath: cmd[1]))
                    driver.onExit { driver, status in
                        exitStatus = status
                    }
                    
                    try driver.launch(arguments: args, checkinData: checkin) { driver, task, thread, state in
                        let pc = thread_state64_get_pc(&state)
                        let lr = thread_state64_get_lr(&state)
                        
                        switch pc {
                        case 0x4142434404:
                            // Done notification
                            Logger.print("Got child notification!")
                            Logger.print(String(format: "Kernel base @ %p", state.__x.0))
                            Logger.print(String(format: "Kernel slide %p", state.__x.0 &- 0xFFFFFFF007004000))
                            Logger.print(String(format: "Virtual base @ %p", state.__x.1))
                            Logger.print(String(format: "Physical base @ %p", state.__x.2))
                            
                            kernelBase  = state.__x.0
                            kernelSlide = state.__x.0 &- 0xFFFFFFF007004000
                            
                            // Lock both locks to ensure threads will block later on
                            // FIXME: This should be somewhere else
                            sendRequestLock.lock()
                            replyLock.lock()
                            
                            done = true
                            
                        case 0x4841585800:
                            // Patchfind
                            return handlePatchfindRequest(driver, task, thread, &state)
                            
                        case 0x4841585808:
                            // Set exception handler
                            exceptionHandler = state.__x.0
                            break
                            
                        case 0x484158580C:
                            // Get request
                            // Attempt to lock the send request lock
                            // (This will block until we have something to send)
                            sendRequestLock.lock()
                            
                            // Ensure all writes are visible
                            OSMemoryBarrier()
                            
                            // Copy Request over to child
                            task.w64(state.__x.0, requestAddrPid)
                            task.w64(state.__x.1, requestSize)
                            if let rb = requestBuf {
                                task.write(addr: state.__x.2, data: rb)
                            }
                            
                            state.__x.0 = request
                            
                        case 0x4841585810:
                            // Set reply values
                            replyStatus = state.__x.0
                            replyResult = state.__x.1
                            if state.__x.3 != 0 {
                                replyBuf = task.read(addr: state.__x.2, size: Int(state.__x.3))
                            } else {
                                replyBuf = nil
                            }
                            
                            // Ensure all writes are visible
                            OSMemoryBarrier()
                            
                            replyLock.unlock()
                            
                        case 0x4841585814:
                            // Kernel exploit done notification
                            Logger.print("Attempting to copy out DK ports...")
                            let dkServerPortName = mach_port_name_t(state.__x.0)
                            let devPortName      = mach_port_name_t(state.__x.1)
                            
                            var dkServerPort: mach_port_t = 0
                            var devPort:      mach_port_t = 0
                            
                            var acquired: mach_msg_type_name_t = 0
                            
                            var kr = mach_port_extract_right(task.tp, dkServerPortName, mach_msg_type_name_t(MACH_MSG_TYPE_COPY_SEND), &dkServerPort, &acquired)
                            guard kr == KERN_SUCCESS else {
                                Logger.print("Failed to copyout dkServerPort: \(kr)")
                                return KERN_FAILURE
                            }
                            
                            kr = mach_port_extract_right(task.tp, devPortName, mach_msg_type_name_t(MACH_MSG_TYPE_COPY_SEND), &devPort, &acquired)
                            guard kr == KERN_SUCCESS else {
                                Logger.print("Failed to copyout devPort: \(kr)")
                                return KERN_FAILURE
                            }
                            
                            Logger.print("Copied out DK ports!")
                            
                            // FIXME: Initialize KRW here...

                        case 0x4841585818:
                            let index = state.__x.0
                            if index < bootInfoSetNames.count {
                                let name = bootInfoSetNames[Int(index)]
                                let value = state.__x.1
                                writeBootInfoCache(name: name, value: value)
                            }

                        case 0x484158581C:
                            let index = state.__x.0
                            if index < bootInfoSetNames.count {
                                let name = bootInfoSetNames[Int(index)]
                                let dataPtr = state.__x.1
                                let dataSize = state.__x.2
                                let data = task.read(addr: dataPtr, size: Int(dataSize))
                                writeBootInfoCache(name: name, value: data!)
                            }
                            
                        default:
                            if let exceptionHandler = exceptionHandler {
                                thread_state64_set_pc(&state, exceptionHandler)
                                return KERN_SUCCESS
                            } else {
                                return KERN_FAILURE
                            }
                        }
                        
                        thread_state64_set_pc(&state, lr)
                        return KERN_SUCCESS
                    }
                    
                    comm.sendCommand("ok")
                } catch let e {
                    Logger.print("SpawnDriver failed: \(e)")
                    
                    comm.sendCommand("error", "SpawnDrv failed!")
                }
                
            case "waitUntilDone":
                while !done && exitStatus == nil {
                    usleep(10000)
                }
                
                if done {
                    /*if let mapped = oobPCIMapMagicPage(pid: getpid()) {
                        Logger.print("Mapped: \(String(format: "%p", mapped.magicPageUInt64))")
                        Logger.print("Content: \(String(format: "%p", mapped.magicPage[0]))")
                        
                        comm.sendCommand("done")
                    } else {
                        Logger.print("Uh-oh, oobPCIMapMagicPage failed!")
                        
                        comm.sendCommand("error", "oobPCIMapMagicPage")
                    }*/
                    
                    comm.sendCommand("done")
                } else {
                    comm.sendCommand("error", "Exit status: \(exitStatus.unsafelyUnwrapped)")
                }
                
            case "startEnvironment":
                do {
                    setenv("PATH", "/sbin:/bin:/usr/sbin:/usr/bin:/var/jb/sbin:/var/jb/bin:/var/jb/usr/sbin:/var/jb/usr/bin", 1)
                    setenv("TERM", "xterm-256color", 1)

                    Logger.print("Status: Loading Basebin Trustcache")
                    let krw = KRWHandler()
                    let basebinTCPath = Bundle.main.bundlePath + "/basebin.tc"
                    let basebinTCKaddr = try tcload(tcPath: basebinTCPath, krw: krw, slide: kernelSlide)
                    writeBootInfoCache(name: "basebin_trustcache_kaddr", value:basebinTCKaddr);

                    Logger.print("Status: Bootstrapping")
                    try Bootstrapper.extractBootstrap()
                    patchBaseBinLaunchDaemonPlists()

                    Logger.print("Status: Starting jailbreakd")
                    try startJailbreakd()

                    let dpDefaults = dopamineDefaults()
                    let iDownloadEnabled = dpDefaults.bool(forKey: "iDownloadEnabled")
                    let tweakInjectionEnabled = dpDefaults.bool(forKey: "tweakInjectionEnabled")

                    if (iDownloadEnabled) {
                        Logger.print("Status: Starting iDownload")
                        _ = execCmd(args: ["/var/jb/basebin/jbinit", "start_idownload"])
                    }

                    Logger.print("Status: Rebuilding TrustCache")
                    _ = jbdRebuildTrustCache()

                    if Bootstrapper.needsFinalize() {
                        Logger.print("Status: Finalizing Bootstrap")
                        try Bootstrapper.finalizeBootstrap()
                    }

                    try updateTweakInjectionPreference()

                    Logger.print("Status: Initializing Environment")
                    let initRet = jbdInitEnvironment()
                    if initRet != 0 {
                        throw JailbreakError.custom("Failed to initialize environment, error code: \(initRet)")
                    }

                    Logger.print("Status: Initializing System Hook")
                    _ = execCmd(args: ["/var/jb/basebin/opainject", "1", "/var/jb/basebin/launchdhook.dylib"])

                    if !tweakInjectionEnabled {
                        // TODO: When icon cache hooks are implemented, just kill cfprefsd and lsd here

                        Logger.print("Status: Starting Launch Daemons")
                        _ = execCmd(args: ["/var/jb/usr/bin/launchctl", "bootstrap", "system", "/var/jb/Library/LaunchDaemons"])

                        Logger.print("Status: Refreshing Icon Cache")
                        _ = execCmd(args: ["/var/jb/usr/bin/killall", "-9", "iconservicesagent"])
                        _ = execCmd(args: ["/var/jb/usr/bin/uicache", "-a"])
                    }

                    handleWifiFixAfterJailbreak { message in
                        Logger.print("Status: \(message)")
                    }

                    comm.sendCommand("done")
                    exit(0)
                } catch let e {
                    Logger.print("Post exploit failure: \(e)")
                    comm.sendCommand("error", "Post exploit failure: \(e)")
                }

            default:
                comm.sendCommand("error", "Unknown command \(cmd[0])!")
            }
        }
    }

    internal static func writeBootInfoCache(name: String, value: Any) {
        cachedBootInfo[name] = value
    }

    internal static func runPatchfinder(kernelslide: UInt64, receiveHandler: (_ index: Int, _ name: String, _ value: Any) -> Void) -> Bool {
        var ok: Bool = false
        repeat {
            Logger.print("Loading kernel...")
            var start = time(nil)
            
            guard let pf = patchfinder else {
                Logger.print("Failed: KernelPatchfinder.running")
                break
            }
            
            Logger.print("Loading took \(time(nil) - start) second(s)!")
            
            Logger.print("Patchfinding...")
            
            start = time(nil)
            
            receiveHandler(0, "kernelslide", kernelslide) // Kernel slide
            
            guard let allproc = pf.allproc else {
                Logger.print("Failed: pf.allproc")
                break
            }
            
            receiveHandler(1, "allproc", allproc)
            
            guard let ITK_SPACE = pf.ITK_SPACE else {
                Logger.print("Failed: pf.ITK_SPACE")
                break
            }
            
            receiveHandler(2, "ITK_SPACE", ITK_SPACE)
            
            guard let cpu_ttep = pf.cpu_ttep else {
                Logger.print("Failed: pf.cpu_ttep")
                break
            }
            
            receiveHandler(3, "cpu_ttep", cpu_ttep)
            
            guard let pmap_enter_options_addr = pf.pmap_enter_options_addr else {
                Logger.print("Failed: pf.pmap_enter_options_addr")
                break
            }
            
            receiveHandler(4, "pmap_enter_options_addr", pmap_enter_options_addr)
            
            guard let hw_lck_ticket_reserve_orig_allow_invalid_signed = pf.hw_lck_ticket_reserve_orig_allow_invalid_signed else {
                Logger.print("Failed: pf.hw_lck_ticket_reserve_orig_allow_invalid_signed")
                break
            }
            
            receiveHandler(5, "hw_lck_ticket_reserve_orig_allow_invalid_signed", hw_lck_ticket_reserve_orig_allow_invalid_signed)
            
            guard let hw_lck_ticket_reserve_orig_allow_invalid = pf.hw_lck_ticket_reserve_orig_allow_invalid else {
                Logger.print("Failed: pf.hw_lck_ticket_reserve_orig_allow_invalid")
                break
            }
            
            receiveHandler(6, "hw_lck_ticket_reserve_orig_allow_invalid", hw_lck_ticket_reserve_orig_allow_invalid)
            
            guard let br_x22_gadget = pf.br_x22_gadget else {
                Logger.print("Failed: pf.br_x22_gadget")
                break
            }
            
            receiveHandler(7, "br_x22_gadget", br_x22_gadget)
            
            guard let exception_return = pf.exception_return else {
                Logger.print("Failed: pf.exception_return")
                break
            }
            
            receiveHandler(8, "exception_return", exception_return)
            
            guard let ldp_x0_x1_x8_gadget = pf.ldp_x0_x1_x8_gadget else {
                Logger.print("Failed: pf.ldp_x0_x1_x8_gadget")
                break
            }
            
            receiveHandler(9, "ldp_x0_x1_x8_gadget", ldp_x0_x1_x8_gadget)
            
            guard let exception_return_after_check = pf.exception_return_after_check else {
                Logger.print("Failed: pf.exception_return_after_check")
                break
            }
            
            receiveHandler(10, "exception_return_after_check", exception_return_after_check)
            
            guard let exception_return_after_check_no_restore = pf.exception_return_after_check_no_restore else {
                Logger.print("Failed: pf.exception_return_after_check_no_restore")
                break
            }
            
            receiveHandler(11, "exception_return_after_check_no_restore", exception_return_after_check_no_restore)
            
            guard let str_x8_x9_gadget = pf.str_x8_x9_gadget else {
                Logger.print("Failed: pf.str_x8_x9_gadget")
                break
            }
            
            receiveHandler(12, "str_x8_x9_gadget", str_x8_x9_gadget)
            
            guard let str_x0_x19_ldr_x20 = pf.str_x0_x19_ldr_x20 else {
                Logger.print("Failed: pf.str_x0_x19_ldr_x20")
                break
            }
            
            receiveHandler(13, "str_x0_x19_ldr_x20", str_x0_x19_ldr_x20)
            
            guard let pmap_set_nested = pf.pmap_set_nested else {
                Logger.print("Failed: pf.pmap_set_nested")
                break
            }
            
            receiveHandler(14, "pmap_set_nested", pmap_set_nested)
            
            guard let pmap_nest = pf.pmap_nest else {
                Logger.print("Failed: pf.pmap_nest")
                break
            }
            
            receiveHandler(15, "pmap_nest", pmap_nest)
            
            guard let pmap_remove_options = pf.pmap_remove_options else {
                Logger.print("Failed: pf.pmap_remove_options")
                break
            }
            
            receiveHandler(16, "pmap_remove_options", pmap_remove_options)
            
            guard let pmap_mark_page_as_ppl_page = pf.pmap_mark_page_as_ppl_page else {
                Logger.print("Failed: pf.pmap_mark_page_as_ppl_page")
                break
            }
            
            receiveHandler(17, "pmap_mark_page_as_ppl_page", pmap_mark_page_as_ppl_page)
            
            guard let pmap_create_options = pf.pmap_create_options else {
                Logger.print("Failed: pf.pmap_create_options")
                break
            }
            
            receiveHandler(18, "pmap_create_options", pmap_create_options)
            
            guard let ml_sign_thread_state = pf.ml_sign_thread_state else {
                Logger.print("Failed: pf.ml_sign_thread_state")
                break
            }
            
            receiveHandler(19, "ml_sign_thread_state", ml_sign_thread_state)
            
            guard let kernel_el = pf.kernel_el else {
                Logger.print("Failed: pf.kernel_el")
                break
            }
            
            receiveHandler(20, "kernel_el", kernel_el << 2)
            
            guard let TH_RECOVER = pf.TH_RECOVER else {
                Logger.print("Failed: pf.TH_RECOVER")
                break
            }
            
            receiveHandler(21, "TH_RECOVER", TH_RECOVER)
            
            guard let TH_KSTACKPTR = pf.TH_KSTACKPTR else {
                Logger.print("Failed: pf.TH_KSTACKPTR")
                break
            }
            
            receiveHandler(22, "TH_KSTACKPTR", TH_KSTACKPTR)
            
            guard let ACT_CONTEXT = pf.ACT_CONTEXT else {
                Logger.print("Failed: pf.ACT_CONTEXT")
                break
            }
            
            receiveHandler(23, "ACT_CONTEXT", ACT_CONTEXT)
            
            guard let ACT_CPUDATAP = pf.ACT_CPUDATAP else {
                Logger.print("Failed: pf.ACT_CPUDATAP")
                break
            }
            
            receiveHandler(24, "ACT_CPUDATAP", ACT_CPUDATAP)
            
            var PORT_KOBJECT: UInt64 = 0x58
            if ProcessInfo.processInfo.operatingSystemVersion.majorVersion >= 15 && ProcessInfo.processInfo.operatingSystemVersion.minorVersion >= 4 {
                PORT_KOBJECT = 0x48
            }
            
            receiveHandler(25, "PORT_KOBJECT", PORT_KOBJECT)
            
            guard let VM_MAP_PMAP = pf.VM_MAP_PMAP else {
                Logger.print("Failed: pf.VM_MAP_PMAP")
                break
            }
            
            receiveHandler(26, "VM_MAP_PMAP", VM_MAP_PMAP)
            
            guard let PORT_LABEL = pf.PORT_LABEL else {
                Logger.print("Failed: pf.PORT_LABEL")
                break
            }
            
            receiveHandler(27, "PORT_LABEL", PORT_LABEL)
            
            guard let pmap_alloc_page_for_kern = pf.pmap_alloc_page_for_kern else {
                Logger.print("Failed: pf.pmap_alloc_page_for_kern")
                break
            }
            
            receiveHandler(28, "pmap_alloc_page_for_kern", pmap_alloc_page_for_kern)

            guard let kalloc_data_external = pf.kalloc_data_external else {
                Logger.print("Failed: pf.kalloc_data_external")
                break
            }

            receiveHandler(29, "kalloc_data_external", kalloc_data_external)

            guard let gPhysBase = pf.gPhysBase else {
                Logger.print("Failed: pf.gPhysBase")
                break
            }
            receiveHandler(30, "gPhysBase", gPhysBase)

            guard let gPhysSize = pf.gPhysSize else {
                Logger.print("Failed: pf.gPhysSize")
                break
            }
            receiveHandler(31, "gPhysSize", gPhysSize)


            // below here only written to disk for later use by base binaries

            guard let kfree_data_external = pf.kfree_data_external else {
                Logger.print("Failed: pf.kfree_data_external")
                break
            }
            receiveHandler(-1, "kfree_data_external", kfree_data_external)

            guard let pmap_image4_trust_caches = pf.pmap_image4_trust_caches else {
                Logger.print("Failed: pf.pmap_image4_trust_caches")
                break
            }
            receiveHandler(-1, "pmap_image4_trust_caches", pmap_image4_trust_caches)

            /*guard let ptrauth_utils_sign_blob_generic = pf.ptrauth_utils_sign_blob_generic else {
                Logger.print("Failed: pf.ptrauth_utils_sign_blob_generic")
                break
            }
            receiveHandler(-1, "ptrauth_utils_sign_blob_generic", ptrauth_utils_sign_blob_generic)

            guard let cs_allow_invalid = pf.cs_allow_invalid else {
                Logger.print("Failed: pf.cs_allow_invalid")
                break
            }
            receiveHandler(-1, "cs_allow_invalid", cs_allow_invalid)

            guard let kernel_mount = pf.kernel_mount else {
                Logger.print("Failed: pf.kernel_mount")
                break
            }
            receiveHandler(-1, "kernel_mount", kernel_mount)

            guard let kerncontext = pf.kerncontext else {
                Logger.print("Failed: pf.kerncontext")
                break
            }
            receiveHandler(-1, "kerncontext", kerncontext)*/

            guard let proc_find = pf.proc_find else {
                Logger.print("Failed: pf.proc_find")
                break
            }
            receiveHandler(-1, "proc_find", proc_find)

            guard let proc_rele = pf.proc_rele else {
                Logger.print("Failed: pf.proc_rele")
                break
            }
            receiveHandler(-1, "proc_rele", proc_rele)

            guard let pacda_gadget = pf.pacda_gadget else {
                Logger.print("Failed: pf.pacda_gadget")
                break
            }
            receiveHandler(-1, "pacda_gadget", pacda_gadget)

            let versionString = Bundle.main.infoDictionary?["CFBundleShortVersionString"] as? String
            if versionString != nil {
                receiveHandler(-1, "basebin-version", versionString!)
            }

            /*guard let mac_label_set = pf.mac_label_set else {
                Logger.print("Failed: pf.mac_label_set")
                break
            }
            receiveHandler(-1, "mac_label_set", mac_label_set)

            guard let OSEntitlements_MetaClass_alloc = pf.OSEntitlements_MetaClass_alloc else {
                Logger.print("Failed: pf.OSEntitlements_MetaClass_alloc")
                break
            }
            receiveHandler(-1, "OSEntitlements_MetaClass_alloc", OSEntitlements_MetaClass_alloc)

            guard let OSEntitlements_Destructor = pf.OSEntitlements_Destructor else {
                Logger.print("Failed: pf.OSEntitlements_Destructor")
                break
            }
            receiveHandler(-1, "OSEntitlements_Destructor", OSEntitlements_Destructor)*/

            Logger.print("Patchfinding took \(time(nil) - start) second(s)!")

            ok = true
        } while false

        return ok
    }
    
    internal static func handlePatchfindRequest(_ driver: SpawnDrv, _ child: Task, _ thread: Thread, _ state: inout arm_thread_state64_t) -> kern_return_t {
        // Patchfind stuff
        let offsetInfoAddr = state.__x.1
        func writeOffsetInfo(_ pos: Int, name: String, value: Any) {
            if pos != -1 {
                if let intValue = value as? UInt64 {
                    child.w64(offsetInfoAddr + UInt64(pos * 8), intValue)
                }
            }
            writeBootInfoCache(name: name, value: value)
        }
        
        let ok = runPatchfinder(kernelslide: state.__x.0 &- 0xFFFFFFF007004000, receiveHandler: writeOffsetInfo)
        
        state.__x.0 = ok ? 1 : 0
        
        let lr = thread_state64_get_lr(&state)
        thread_state64_set_pc(&state, lr)
        
        return ok ? KERN_SUCCESS : KERN_FAILURE
    }

    public static func updateBasebinOffsets() -> Bool {
        let bootInfoURL = URL(fileURLWithPath: prebootPath("basebin/boot_info.plist"))

        func writeBootInfo(_ pos: Int, name: String, value: Any) {
            let bootInfo = NSMutableDictionary(contentsOf: bootInfoURL) ?? NSMutableDictionary()
            bootInfo[name] = value
            try? bootInfo.write(to: bootInfoURL)
        }

        let oldBootInfo = NSDictionary(contentsOf: bootInfoURL) ?? NSDictionary()
        guard let kernelslide = oldBootInfo["kernelslide"] as? UInt64 else {
            return false
        }

        return runPatchfinder(kernelslide: kernelslide, receiveHandler: writeBootInfo)
    }
    
    static func oobPCIRequest(id: UInt64, addrPid: UInt64, size: UInt64 = 0, buf: Data? = nil) -> (status: UInt64, result: UInt64, data: Data?) {
        // Take the request lock
        requestLock.lock()
        
        // Write request
        request        = id
        requestAddrPid = addrPid
        requestSize    = size
        requestBuf     = buf
        
        // Ensure all writes are visible
        OSMemoryBarrier()
        
        // Send the request
        sendRequestLock.unlock()
        
        // Acquire reply lock
        replyLock.lock()
        
        // Ensure all writes are visible
        OSMemoryBarrier()
        
        let res = (status: replyStatus, result: replyResult, data: replyBuf)
        
        // Ensure read is not re-ordered
        OSMemoryBarrier()
        
        requestLock.unlock()
        
        return res
    }
    
    /*static func oobPCIMapMagicPage(pid: pid_t) -> PPLRW? {
        let rsp = oobPCIRequest(id: 7, addrPid: UInt64(pid))
        guard rsp.status == 0 else {
            Logger.print("oobPCI failed to map magic PPL page! Status: \(rsp.status)")
            return nil
        }
        
        return PPLRW(magicPage: rsp.result)
    }*/
}
