import CBindings;
import PatchfinderUtils;

public enum BootstrapError: Error {
    case custom(_: String)
}


class Bootstrapper {
    static func remountPrebootPartition(writable: Bool) -> Int32? {
        if writable {
            return execCmd(args: ["/sbin/mount", "-u", "-w", "/private/preboot"])
        } else {
            return execCmd(args: ["/sbin/mount", "-u", "/private/preboot"])
        }
	}
    
    static func untar(tarPath: String, target: String) -> Int32? {
        let tarBinary = Bundle.main.bundlePath + "/tar"
        try? FileManager.default.setAttributes([.posixPermissions: 0o755], ofItemAtPath: tarBinary)
        return execCmd(args: [tarBinary, "-xpkf", tarPath, "-C", target]);
    }

    static func getBootManifestHash() -> String {
        let registryEntry = IORegistryEntryFromPath(kIOMainPortDefault, "IODeviceTree:/chosen")
        let bootManifestHash = IORegistryEntryCreateCFProperty(registryEntry, "boot-manifest-hash" as CFString, kCFAllocatorDefault, 0).takeRetainedValue() as! Data
        return bootManifestHash.map { String(format: "%02X", $0) }.joined()
    }

	static func generateFakeRootPath() -> String {
		let letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
		var result = ""
		for _ in 0..<6 {
			let randomIndex = Int(arc4random_uniform(UInt32(letters.count)))
			let randomCharacter = letters[letters.index(letters.startIndex, offsetBy: randomIndex)]
			result += String(randomCharacter)
		}
		return "/private/preboot/" + getBootManifestHash() + "/jb-" + result
	}

	static func locateExistingFakeRoot() -> String? {
        let ppURL = URL(fileURLWithPath: "/private/preboot/" + getBootManifestHash())
        guard let candidateURLs = try? FileManager.default.contentsOfDirectory(at: ppURL , includingPropertiesForKeys: nil, options: []) else { return nil }
		for candidateURL in candidateURLs {
			if candidateURL.lastPathComponent.hasPrefix("jb-") {
				return candidateURL.path
			}
		}
		return nil
	}

    static func wipeXinaSymlink(atPath path: String) throws {
        let fileManager = FileManager.default
        let attributes = try fileManager.attributesOfItem(atPath: path)
        if let fileType = attributes[.type] as? FileAttributeType, fileType == .typeSymbolicLink {
            try fileManager.removeItem(atPath: path)
            Logger.print("[Xina Cleanup] Deleted symlink at \(path)")
        } else {
            Logger.print("[Xina Cleanup] \(path) is not a symlink")
        }
    }

    static func extractBootstrap() throws {
        let jbPath = "/var/jb"

        if remountPrebootPartition(writable: true) != 0 {
            throw BootstrapError.custom("Failed to remount /private/preboot partition as writable")
        }

        // Remove existing /var/jb symlink if it exists (will be recreated later)
        if FileManager.default.fileExists(atPath: jbPath) {
            try FileManager.default.removeItem(atPath: jbPath)
        }

        // If xina was used before, clean the mess it creates in /var
        // Xina will recreate them on the next jb through it so there is no loss here
        let xinaInstalled = FileManager.default.fileExists(atPath: "/var/LIY")
        if xinaInstalled {
            let xinaVarSymlinks = [
                "alternatives",
                "ap",
                "apt",
                "bin",
                "bzip2",
                "cache",
                "dpkg",
                "etc",
                "gzip",
                "lib",
                "Lib",
                "libexec",
                "Library",
                "LIY",
                "Liy",
                "local",
                "newuser",
                "profile",
                "sbin",
                "suid_profile",
                "sh",
                "sy",
                "share",
                "ssh",
                "sudo_logsrvd.conf",
                "suid_profile",
                "sy",
                "usr",
                "zlogin",
                "zlogout",
                "zprofile",
                "zshenv",
                "zshrc"
            ]

            for xinaVarSymlink in xinaVarSymlinks {
                let symlinkPathToWipe = "/var/" + xinaVarSymlink
                try wipeXinaSymlink(atPath: symlinkPathToWipe)
            }
        }
        
        // Ensure fake root directory inside /private/preboot exists
        var fakeRootPath = locateExistingFakeRoot()
        if fakeRootPath == nil {
            fakeRootPath = generateFakeRootPath()
            try FileManager.default.createDirectory(atPath: fakeRootPath!, withIntermediateDirectories: true)
        }
        
        // Extract Procursus Bootstrap if neccessary
        var bootstrapNeedsExtract = false
        let procursusPath = fakeRootPath! + "/procursus"
        let installedPath = procursusPath + "/.installed_fugu15max"
        if FileManager.default.fileExists(atPath: procursusPath) {
            if !FileManager.default.fileExists(atPath: installedPath) {
                Logger.print("Wiping existing bootstrap because installed file not found")
                try FileManager.default.removeItem(atPath: procursusPath)
            }
        }
        if !FileManager.default.fileExists(atPath: procursusPath) {
            try FileManager.default.createDirectory(atPath: procursusPath, withIntermediateDirectories: true)
            bootstrapNeedsExtract = true
        }
        
        // Update basebin (should be done every rejailbreak)
        let basebinTarPath = Bundle.main.bundlePath + "/basebin.tar"
        let basebinPath = procursusPath + "/basebin"
        if FileManager.default.fileExists(atPath: basebinPath) {
            try FileManager.default.removeItem(atPath: basebinPath)
        }
        let untarRet = untar(tarPath: basebinTarPath, target: procursusPath)
        if untarRet != 0 {
            throw BootstrapError.custom(String(format:"Failed to untar Basebin: \(String(describing: untarRet))"))
        }

        // Create /var/jb symlink
        try FileManager.default.createSymbolicLink(atPath: jbPath, withDestinationPath: procursusPath)

        // Extract Procursus if needed
        if bootstrapNeedsExtract {
            let procursusTarPath = Bundle.main.bundlePath + "/bootstrap.tar"
            let untarRet = untar(tarPath: procursusTarPath, target: "/")
            if untarRet != 0 {
                throw BootstrapError.custom(String(format:"Failed to untar Procursus: \(String(describing: untarRet))"))
            }
            try "".write(toFile: installedPath, atomically: true, encoding: String.Encoding.utf8)
        }

        // Write boot info from cache to disk
        let bootInfoURL = URL(fileURLWithPath: "/var/jb/basebin/boot_info.plist")
        try? cachedBootInfo.write(to: bootInfoURL)
    }

    static func needsFinalize() -> Bool {
        return FileManager.default.fileExists(atPath: "/var/jb/prep_bootstrap.sh")
    }

    static func finalizeBootstrap() throws {
        let prepRet = execCmd(args: ["/var/jb/bin/sh", "/var/jb/prep_bootstrap.sh"])
        if prepRet != 0 {
            throw BootstrapError.custom(String(format:"Failed to finalize bootstrap, prep_bootstrap.sh failed with error code: \(prepRet)"))
        }

        let zebraRet = execCmd(args: ["/var/jb/usr/bin/dpkg", "-i", Bundle.main.bundlePath + "/zebra.deb"])
        if zebraRet != 0 {
            throw BootstrapError.custom(String(format:"Failed to finalize bootstrap, installing Zebra failed with error code: \(zebraRet)"))
        }

        let sileoRet = execCmd(args: ["/var/jb/usr/bin/dpkg", "-i", Bundle.main.bundlePath + "/sileo.deb"])
        if sileoRet != 0 {
            throw BootstrapError.custom(String(format:"Failed to finalize bootstrap, installing Sileo failed with error code: \(sileoRet)"))
        }

        execCmd(args: ["/var/jb/usr/bin/uicache", "-u", "/var/jb/Applications/Zebra.app"])
        execCmd(args: ["/var/jb/usr/bin/uicache", "-u", "/var/jb/Applications/Sileo-Nightly.app"])

        // TEMP: Set root pw to "alpine", should be removed later when the main app has the ability to set it
        try FileManager.default.removeItem(atPath: "/var/jb/etc/master.passwd")
        try FileManager.default.copyItem(atPath: Bundle.main.bundlePath + "/master.rootalpine.passwd", toPath: "/var/jb/etc/master.passwd")
        execCmd(args: ["/var/jb/usr/sbin/pwd_mkdb", "-d", "/var/jb/etc", "/var/jb/etc/master.passwd"])
    }

	static func doHide() {
        // Remove existing /var/jb symlink if it exists (will be recreated on next jb)
        // This is the only thing that apps could detect when the device is not actually jailbroken
        // Except for apps that check for random preferences and shit on /var (something no app should ever do because of way to many false positives, feel free to send this comment to your manager)
        
        let jbPath = "/var/jb"

        if remountPrebootPartition(writable: true) != 0 {
            Logger.print("Failed to remount /private/preboot partition as writable")
            return
        }
        
        do {
            if FileManager.default.fileExists(atPath: jbPath) {
                try FileManager.default.removeItem(atPath: jbPath)
            }
        } catch let error as NSError {
            Logger.print("Failed to delete /var/jb symlink: \(error)")
            return
        }
        
        if remountPrebootPartition(writable: false) != 0 {
            Logger.print("Failed to remount /private/preboot partition as non-writable")
            return
        }
	}

	static func doUninstall() {
        let jbPath = "/var/jb"
        
        if remountPrebootPartition(writable: true) != 0 {
            Logger.print("Failed to remount /private/preboot partition as writable")
            return
        }
        
        // Delete /var/jb symlink
        do {
            if FileManager.default.fileExists(atPath: jbPath) {
                try FileManager.default.removeItem(atPath: jbPath)
            }
        } catch let error as NSError {
            Logger.print("Failed to delete /var/jb symlink: \(error)")
            return
        }
        
        // Delete fake root
        let fakeRootPath = locateExistingFakeRoot()
        if fakeRootPath != nil {
            do {
                try FileManager.default.removeItem(atPath: fakeRootPath!)
            }
            catch let error as NSError {
                Logger.print("Failed to delete fake root: \(error)")
                return
            }
        }
        
        if remountPrebootPartition(writable: false) != 0 {
            Logger.print("Failed to remount /private/preboot partition as non-writable")
            return
        }

        // TODO: reload icon cache (?)
	}

	static func isBootstrapped() -> Bool {
        return locateExistingFakeRoot() != nil
	}
}
